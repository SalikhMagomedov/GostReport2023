% TODO: change chapter name
\chapter{Модификация алгоритма динамического программирования для усовершенствования решения задачи о димерных числах}

\section{Основной результат}

Запланированные цели и направления усовершенствования известных из литературы реализаций алгоритма динамического программирования по профилю: 1) уменьшение вычислительной сложности, 2) оптимизация требуемого объема памяти.

Цели оптимизации алгоритма в основном достигнуты, но в процессе исследования оказались вытеснены на второстепенное по значимости место тесными связями с числами Фибоначчи, обнаруженными на различных стадиях решения задачи перечисления разбиений прямоугольника на плитки $1\times 2$ методом динамического программирования по профилю.

%\begin{definition}\label{Def1}
Пусть рассматривается покрытие заданного прямоугольника $M$; пронумеруем плитки покрытия по правилу: <<из двух плиток меньший номер получает та плитка, которая ближе к основанию прямоугольника $M$>> и будем считать, что каждая плитка уложена в момент времени, равный ее номеру. Таким образом, если  хотя бы одна из клеток плитки покрытия ниже обеих клеток другой плитки, то первая плитка уложена раньше  (\textit{правило хронологического покрытия}).
%\hhline  width 2mm

В каждый момент времени состояние покрытости клеток любой строки будем записывать в виде $m$-разрядной двоичной строки, где бит в разряде $j$ равен $1$, если $j$-я клетка строки покрыта плиткой, $0$ -- если $j$-я клетка не покрыта; $j=0,1,\dots,m-1.$  
Обозначим через $t_i$ наименьший момент времени, когда в результате укладки очередной плитки $G$ оказалась покрытой последняя из непокрытых клеток $g$ строки $i-1$.
Двоичный образ строки $i$ в момент времени $t_i$ будем называть $i$-\textit{профилем};
 $i$-профиль $q$ и $(i+1)$-профиль $p$ хронологического покрытия будем называть {\it близкими} профилями.
Для заданного $i$-профиля $q$ количество всевозможных покрытий части исходного прямоугольника, образованной начальными $i+q[j]-1$ клетками каждого $j$-го столбца ($j=0,\dots, m-1$), обозначим $a[i,q]$.
%\end{definition}

Тогда, во-первых, 
\begin{equation}\label{eq2}
a[i+1,p]=\sum_{i-\text{профили}\; q,\, \text{близкие с}\; p}\ a[i,q] ,\,\,                        
i=1,\dots,n;\,\, p=0,…,2^m-1;     
  %\eqno (2)
\end{equation}
во-вторых,
%\begin{color}{red}
\[a[1,0]=1; a[1,1]=\dots=a[1,2^m-1]=0.\]
%\end{color}

Формула \eqref{eq2} приведена в ряде источников
%, например, в \cite{Vol13}--\cite{Vas14}, 
 с нетривиальным уточнением, что искомым результатом будет число $a[n+1,0]$, 
а не $a[n,2^m-1]$.

%Однако вычисления по формуле \eqref{eq2} сопряжены с проблемами малой скорости вычислений и нехватки памяти. 
%
%В последующих разделах обсуждаются пути их преодоления.\par
%\end{fulltext}
\begin{enumerate}
	\item 
Найден эффективно проверяемый критерий совместимости профилей:
%[Критерий совместимости профилей]

Для совместимости $m$-разрядных профилей $q$ и $p$ необходимо и достаточно выполнение следующих условий:\\
$q\boxtimes p=0$ (побитовое произведение $p$ и $q$ равно нулю); \\
побитовая сумма $q\boxplus p$ не содержит нечетных 0-серий.

Для $m=4$ результаты вычислений  см. в таблице \ref{tab02}.

%\\cline{2-9} \cline{11-18
\begin{table}[ht]
  \tiny
\caption{$F_{i,j}=1$, если профили $i$ и $j$ совместимы  ($m=4$)}
%\centering { 
\label{tab02}
%}
\begin{tabular}{*{18}{|c}|}
\hline
\centering
  & p & {0000} & {0001} & {0010} & {0011} & {0100} & {0101} & {0110} & {0111} & {1000} & {1001} & {1010} & {1011} & {1100} & {1101} & {1110} & {1111} \\
\hline
q &  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
\hline
{0000} & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 \\
\hline
{0001} & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
\hline
{0010} & 2 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
\hline
{0011} & 3 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
\hline
{0100} & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
\hline
{0101} & 5 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
\hline
{0110} & 6 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{0111} & 7 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1000} & 8 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1001} & 9 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1010} & 10 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1011} & 11 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1100} & 12 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1101} & 13 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1110} & 14 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
{1111} & 15 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline 
\end{tabular}
\end{table}

\item
Поскольку в практических вопросах сокращение размеров необходимой памяти вдвое --- весьма существенное достижение, отметим еще один шаг в данном направлении.
%\underline{Теорема 2.} 

Профиль $p$: 
1) совместим с каждым профилем вида $2^k-p-1$, $k=2,4,6,\dots,m$,
2) несовместим ни с одним профилем из интервала
$$(2^k-1-p ; 2^{k+1}-1-p).$$

\item
Построен алгоритм, который для любого заданного $m$-разрядного $i$-профиля $q$ генерирует полный список профилей, близких к $q$;\\
мощность списка равна произведению
$$f(d_0+1) \cdot  f(d_1+1)\cdot \dots \cdot  f(d_{r-1}+1),$$
где $f(k)$ обозначает число Фибоначчи с номером $k$, $r$ -- количество 0-серий в $q$, $d_i$ -- длина $i$-й 0-серии.
\item 
Построен модифицированный алгоритм вычисления $\tau(m,n)$, оптимизированный по быстродействию и требуемой оперативной памяти.
Об эффективности построенного алгоритма свидетельствует следующий факт.

Попытка вычислить $\tau(8,18000)$ на основе формулы \eqref{eq2} потерпела неудачу, в то же время модифицированный алгоритм <<без труда>> справился -- при том же программном и аппаратном обеспечении -- с вычислением значения $\tau(m,n)$ при $m=8$, $n=150000$ (приводим лишь начальный и конечный фрагменты десятичной записи числа, полная запись содержит 143189 цифр):
$$\tau(8,150000)=13873887020492488 \dots 05663089457. $$

\end{enumerate}

Перечень результатов:
\begin{enumerate}
	\item 
Выявлены тесные и неожиданные связи вопроса совместимости профилей и чисел Фибоначчи.
При заданном $m$ через $T_m(p)$   обозначим количество профилей, совместимых с профилем $p$.
Справедливы следующие утверждения:\\
1. $T_m(0)=f(m+1)$;\\
2. $T_m(1) = f(m)$;\\
3. $T_m(2)=f(m-1)$;\\
4. $T_m(3)=f(m-1)$;\\
5. $T_m(2^{m-1})=f(m)$;\\
6. $T_m(2^{m-1}+1)=f(m-1)$.\\
7. Для $p\notin \{0,1,2,3,2^{m-1}, 2^{m-1}+1\}$
выполняется неравенство: 
\begin {equation} \label {eq03}
T_m(p) \le f(m).
\end{equation}
\item
Создано программное обеспечение для вычислительного сопровождения результатов.
В качестве иллюстративного материала к теореме в таблице \ref{tab01} приведем значения $T_m(p)$ для $m=4,6,8,10,12,14$; $p=0, 1, 2, 3, 2^{m-1}, 2^{m-1}+1$. В последней строке таблицы  -- неравенство (\ref{eq03}) в <<наглядно-цифровом>> представлении.

\begin{table}[ht]
\caption{Значения $T_m(p)$}
\centering
\label{tab01}
\footnotesize{
\begin{tabular} {|p{2cm}|c|c|c|c|c|c| }
\hline
$p$&$m=4$&$m=6$&$m=8$&$m=10$&$m=12$&$m=14$\\
\hline
\hline
0&5&13&34&89&233&610\\
\hline
1&3&8&21&55&144&377\\
\hline
2&2&5&13&34&89&233\\
\hline
3&2&5&13&34&89&233\\
\hline
$2^{m-1}$&3&8&21&55&44&377\\
\hline
$2^{m-1}+1$&2&5&13&34&89&233\\
\hline
\hline
см. \eqref{eq03}&$2\leq 3$&$6\leq 8 $&$16\leq 21$&$42\leq 55$&$110\leq 144$&$288 \leq 377$\\
\hline
\end{tabular}
}
\end{table}
\item 
Из верхней строки прямоугольника $M(m\times n)$, $m$-четное, вырезали несколько клеток, образовавшиеся пустые квадратики будем называть <<пустышками>>, а саму верхнюю строку -- <<кластером>>. Информацию о кластере будем хранить в $m$-битной строке \linebreak $p=(p_0, p_1, \dots, p_{m-1})$, где 
$p_j$ равно нулю, если $j$-я позиция кластера занята пустышкой, и $p_j$ равно единице, если в $j$-й позиции сохранилась клетка. Кластер назовем правильным, если количество клеток в позициях с четными номерами равно количеству клеток в позициях с нечетными номерами. Результат замены в каждой позиции кластера <<клетка --- пустышка>> назовем инверсным для исходного кластера. Кластер, инверсный к правильному, также является правильным.
Оставшуюся часть прямоугольника $M$ будем называть {\it полосой} $M_p(k,n)$.

Исходную полосу $M$ всегда можно преобразовать к <<стандартному представлению>> --- эквивалентной полосе (т.е. к полосе, которая покрывается или не покрывается плитками одновременно с исходной полосой), где в кластере из каждой нечетной 1-серии клеток сохраняется лишь одна \textit{изолированная}  клетка, крайняя для 1-серии.

\item
Если в кластере все внутренние 0-серии четные, а крайние 0-серии нечетные, то при $n=2$ полоса не допускает покрытие, при $n>2$ покрытие существует.
\item
Если все 0-серии кластера четные, то полоса допускает покрытие. 
%В кластере стандартного представления 0-серии между соседними изолированными единицами будем называть \textit{внутренними}, остальные 0-серии --- \textit{крайними}.

Если все 0-серии кластера полосы $M (m\times n)$ нечетные и $k$ ---  количество единиц, то
 для существования покрытия необходимо выполнение условия: $2k\leq n$.
\item
Если в начале кластера полосы $M (m\times n)$ расположены нечетные 0-серии, разделяемые $k$ изолированными единицами, то
 для существования покрытия необходимо выполнение условия: $2k\leq n$.

\item
Анализ повторяемости цифр в десятичной записи димерных чисел (д.з.д.ч.). Масштабные вычислительные эксперименты, проведенные с программой (число цифр в д.з.д.ч. достигало несколько десятков тысяч), показали, что с ростом размеров прямоугольника частоты вхождения различных цифр в д.з.д.ч. выравниваются. 

\end{enumerate}
